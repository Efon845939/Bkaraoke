/**
 * @fileOverview
 * Core Philosophy:
 * This ruleset enforces a dual-level access control model for song requests. Admins have full access to all song requests, while students can only manage their own requests.
 *
 * Data Structure:
 * - Students profiles are stored under `/students/{studentId}`.
 * - Song requests are stored in a flat collection at `/song_requests/{songRequestId}`.
 *
 * Key Security Decisions:
 * - Listing of song requests is restricted to admins only. Students cannot see the entire list of requests.
 * - An anonymous auth provider is being used, so special care must be taken to prevent unauthorized access to data by unauthenticated users.
 *
 * Denormalization for Authorization:
 * Song requests include a `studentId` field, denormalized from the `/students/{studentId}` document. This allows rules to efficiently check ownership without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages student profiles, allowing only authenticated users to create their own profile and no one to modify other profiles.
     * @path /students/{studentId}
     * @allow (create) - User with UID 'user_abc' can create their profile at /students/user_abc with matching id.
     * @deny (create) - User with UID 'user_abc' cannot create a profile at /students/user_xyz.
     * @deny (update) - User with UID 'user_abc' cannot update the profile at /students/user_xyz.
     * @deny (delete) - User with UID 'user_abc' cannot delete the profile at /students/user_xyz.
     * @principle Enforces strict user-ownership for student profiles.
     */
    match /students/{studentId} {
      allow get: if isSignedIn() && isOwner(studentId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(studentId);
      allow update: if isSignedIn() && isOwner(studentId);
      allow delete: if isSignedIn() && isOwner(studentId);
    }

    /**
     * @description Manages song requests, allowing admins to manage all requests and students to manage only their own.
     * @path /song_requests/{songRequestId}
     * @allow (create) - User with UID 'user_abc' can create a song request with studentId 'user_abc'.
     * @allow (update) - User with UID 'user_abc' can update a song request with studentId 'user_abc'.
     * @allow (delete) - User with UID 'user_abc' can delete a song request with studentId 'user_abc'.
     * @deny (create) - User with UID 'user_abc' cannot create a song request with studentId 'user_xyz'.
     * @deny (update) - User with UID 'user_abc' cannot update a song request with studentId 'user_xyz'.
     * @deny (delete) - User with UID 'user_abc' cannot delete a song request with studentId 'user_xyz'.
     * @principle Enforces ownership for students, and admin override.
     */
    match /song_requests/{songRequestId} {
      allow get: if isAdmin() || isSongRequestOwner();
      allow list: if isAdmin();
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update: if isSignedIn() && (isAdmin() || isSongRequestOwner());
      allow delete: if isSignedIn() && (isAdmin() || isSongRequestOwner());
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      // TODO: Implement logic to check if the user is an admin (e.g., based on a custom claim).
      return false;
    }

    function isSongRequestOwner() {
      return resource.data.studentId == request.auth.uid;
    }
  }
}