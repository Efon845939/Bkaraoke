/**
 * @fileoverview Firestore Security Rules for the Karaoke Request App.
 *
 * Core Philosophy:
 * This ruleset employs a hybrid security model, balancing open access for song requests with strict owner-only access for user profiles.
 *
 * Data Structure:
 * - /students/{studentId}: Stores user profiles, accessible only to the owning user and admins.
 * - /song_requests/{songRequestId}: Stores all song requests, publicly readable but writable only with valid user authentication and ownership.
 * - /audit_logs/{logId}: Stores audit logs, writable only by admins.
 *
 * Key Security Decisions:
 * - User profiles are private; listing all users is disallowed.
 * - Song requests are publicly readable to allow for a live queue display.
 * - Data shapes are not strictly enforced to allow rapid iteration.
 *
 * Denormalization for Authorization:
 * - Song requests contain the `studentId` to enable easy owner-only write checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by an authenticated user.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user's ID matches the resource's studentId
     */
    function isSongRequestOwner(studentId) {
        return isSignedIn() && request.auth.uid == studentId;
    }

    /**
     * @description Checks if the user is an admin. This requires denormalizing the role on the Student document.
     * @param studentId The ID of the student to check.
     */
    function isAdmin(studentId) {
        return get(/databases/$(database)/documents/students/$(studentId)).data.role == 'admin';
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces that the incoming song request contains the correct studentId matching the authenticated user.
     */
    function isValidSongRequestCreate() {
        return request.resource.data.studentId == request.auth.uid;
    }

    /**
     * @description Checks if the authenticated user is authorized to delete their account.
     * Users can delete their own account only.
     */
    function canDeleteAccount(studentId) {
      return isOwner(studentId);
    }

    /**
     * @description
     *  Rules for /students/{studentId} collection.
     *  - Only the user themselves or an admin can read/write their profile.
     *  - No listing of all users.
     * @path /students/{studentId}
     * @allow (get) User 'user_abc' can read their own profile.
     * @allow (create) User 'user_abc' can create their own profile if request.auth.uid == studentId.
     * @allow (update) User 'user_abc' can update their own profile.
     * @allow (delete) User 'user_abc' can delete their own profile.
     * @deny (get) User 'user_xyz' cannot read user_abc's profile.
     * @deny (list) No one can list all user profiles.
     * @principle Enforces document ownership for writes and reads.
     */
    match /students/{studentId} {
      // Read rules: Only the user or an admin can read the profile
      allow get: if isOwner(studentId) || isAdmin(studentId);
      allow list: if false;

      // Write rules: Only the user can create, update, or delete their profile.
      allow create: if isOwner(studentId) && request.resource.data.id == studentId;
      allow update: if isExistingOwner(studentId) && request.resource.data.id == resource.data.id;
      allow delete: if canDeleteAccount(studentId);
    }

    /**
     * @description
     *  Rules for /song_requests/{songRequestId} collection.
     *  - Anyone can read song requests.
     *  - Only authenticated users can create song requests, and their studentId must match their auth UID.
     *  - Only the owner can update/delete a song request.
     * @path /song_requests/{songRequestId}
     * @allow (get) Anyone can get a song request.
     * @allow (list) Anyone can list song requests.
     * @allow (create) User 'user_abc' can create a song request if request.resource.data.studentId == request.auth.uid.
     * @deny (create) User 'user_abc' cannot create a song request with studentId = 'user_xyz'.
     * @allow (update) User 'user_abc' can update their own song request.
     * @allow (delete) User 'user_abc' can delete their own song request.
     * @principle Public read, owner-only writes.  Validates the studentId on create.
     */
    match /song_requests/{songRequestId} {
      // Read rules: Public read
      allow get, list: if true;

      // Write rules: Owner-only writes, with studentId validation on create.
      allow create: if isSignedIn() && isValidSongRequestCreate();
      allow update: if isSongRequestOwner(resource.data.studentId) && resource != null;
      allow delete: if isSongRequestOwner(resource.data.studentId) && resource != null;
    }

      /**
       * @description
       *  Rules for /audit_logs/{logId} collection.
       *  - Only admins can create audit logs.
       *  - No one can read, update, delete, or list audit logs.
       * @path /audit_logs/{logId}
       * @allow (create) Admin can create an audit log.
       * @deny (get) Non-admin cannot get an audit log.
       * @deny (list) Non-admin cannot list audit logs.
       * @deny (update) Non-admin cannot update an audit log.
       * @deny (delete) Non-admin cannot delete an audit log.
       * @principle Admin-only writes, no reads.
       */
      match /audit_logs/{logId} {
          // Write rules: Admin-only writes
          allow create: if isAdmin(request.auth.uid);
          allow get: if false;
          allow list: if false;
          allow update: if false;
          allow delete: if false;
      }
  }
}