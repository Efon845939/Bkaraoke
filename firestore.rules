/**
 * @fileoverview Firestore Security Rules for Song Request App
 *
 * Core Philosophy:
 * This ruleset prioritizes ease of prototyping while maintaining strict authorization.
 * It enforces user-ownership where applicable but avoids overly strict data validation.
 *
 * Data Structure:
 * - /students/{studentId}: Stores student profiles, accessible only to the owner (the student themselves).
 * - /song_requests/{songRequestId}: Stores all song requests. Publicly readable, but writable only by authorized users.
 *
 * Key Security Decisions:
 * - Users can only read their own student profiles. Listing all students is disallowed.
 * - Song requests are publicly readable to allow for display on a shared interface, but creation, updates, and deletion are disallowed given the lack of defined role or ownership.
 *
 *  Denormalization for Authorization:
 *  - The `SongRequest` entity could benefit from denormalization of an `ownerId` or similar field
 *  to control write access. For now, write access is denied.
 *  - The student name is denormalized on the song request for easier display without needing a separate lookup.
 *
 * Structural Segregation:
 * - Public and private data is segregated into separate collections: `song_requests` for public display and `/students/{studentId}` for private student data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows a student to read and write their own profile.
     * @path /students/{studentId}
     * @allow (get, create, update, delete) if the user's UID matches the studentId.
     * @deny (get, create, update, delete) if the user's UID does not match the studentId.
     * @principle Enforces document ownership for all operations.
     */
    match /students/{studentId} {
      allow get: if isOwner(studentId);
      allow list: if false; // Do not allow listing of all students.
      allow create: if isOwner(studentId) && request.resource.data.id == studentId;
      allow update: if isExistingOwner(studentId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(studentId);
    }

    /**
     * @description Allows anyone to read song requests, but restricts creation, updates, and deletion given no clear ownership or role definitions.
     * @path /song_requests/{songRequestId}
     * @allow (get, list) Allows anyone to read all song requests.
     * @deny (create, update, delete) since there are no ownership fields defined.
     * @principle Public read access with restricted writes due to lack of an owner.
     */
    match /song_requests/{songRequestId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the current user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user is the owner of the resource.
     * @param {string} userId The user ID to compare against the request's auth UID.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is the owner of the resource and the resource exists.
     * @param {string} userId The user ID to compare against the request's auth UID.
     * @return {bool} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}