/**
 * @fileoverview Firestore Security Rules for the Karaoke Request App.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for student profiles, allowing students to only manage their own profile data.
 * Song requests are stored in a public collection but can only be created with a valid studentId.
 *
 * Data Structure:
 * - /students/{studentId}: Stores individual student profiles.  The `studentId` must match the authenticated user's UID.
 * - /song_requests/{songRequestId}: Stores all song requests.
 *
 * Key Security Decisions:
 * - Students can only read and write their own profile data.
 * - The `studentId` and `studentName` fields in the `song_requests` collection are used for authorization, ensuring requests are associated with valid student profiles.
 * - Listing all students is disallowed for privacy.
 *
 * Denormalization for Authorization:
 * - Song requests denormalize `studentId` and `studentName` to simplify authorization rules and avoid costly `get()` calls.
 *
 * Structural Segregation:
 * - Student profiles and song requests are stored in separate top-level collections, reflecting their different access patterns.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rule for the /students collection.
     * @path /students/{studentId}
     * @allow (create) Authenticated user can create their own student profile if the studentId matches their UID.
     * @deny (create) Authenticated user cannot create a student profile with a mismatched studentId.
     * @allow (get, update, delete) Authenticated user can read/update/delete their own student profile.
     * @deny (get, update, delete) Authenticated user cannot read/update/delete another user's student profile.
     * @principle Enforces document ownership for writes and reads.
     */
    match /students/{studentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isOwner(studentId);
      allow list: if false; // Listing students is disallowed for privacy.
      allow create: if isOwner(studentId);
      allow update: if isExistingOwner(studentId);
      allow delete: if isExistingOwner(studentId);
    }

     /**
      * @description Rule for the /song_requests collection.
      * @path /song_requests/{songRequestId}
      * @allow (create) Authenticated user can create a song request if the studentId matches their UID.
      * @deny (create) Authenticated user cannot create a song request with a mismatched studentId.
      * @allow (get, list) Any user can read song requests.
      * @allow (update, delete) No one can update or delete song requests.
      * @principle Public read access with owner-only writes.
      */
    match /song_requests/{songRequestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isStudent(studentId) {
        return isSignedIn() && request.auth.uid == studentId;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }
  }
}