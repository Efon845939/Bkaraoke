/**
 * @fileoverview Firestore Security Rules for Karaoke App
 *
 * Core Philosophy:
 * This ruleset enforces a combination of role-based access control (for owners/admins) and user-based access control (for students) to protect data.
 *
 * Data Structure:
 * - /students/{studentId}: Stores student and admin profiles.
 * - /song_requests/{songRequestId}: Stores all song requests. Contains denormalized studentId for security.
 * - /audit_logs/{logId}: Stores audit logs.
 *
 * Key Security Decisions:
 * - Owners (emails matching *@karaoke\.owner\.app$) have full access to all data.
 * - Admins (emails matching *@karaoke\.admin\.app$) have read access to song requests.
 * - Students (emails matching *@karaoke\.app$) can only read/write their own student profile and create song requests.
 * - Students can read song requests that have them listed as the owner
 * - Students should filter song requests using `where("studentId", "==", uid)` to only show the relevant song requests.
 * - Audit logs are readable only by owners, creatable by anyone.
 *
 * Denormalization for Authorization:
 * - The `song_requests` collection includes the `studentId` field to avoid needing to query the `students` collection for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for authentication and authorization
    function signedIn() {
      return request.auth != null;
    }

    function hasEmail() {
      return signedIn() && request.auth.token.email != null;
    }

    function isOwner() {
      return hasEmail() && request.auth.token.email.matches(".*@karaoke\\.owner\\.app$");
    }

    function isAdmin() {
      return hasEmail() && request.auth.token.email.matches(".*@karaoke\\.admin\\.app$");
    }

    function isStudent() {
      return hasEmail() && request.auth.token.email.matches(".*@karaoke\\.app$");
    }

    function isOwnerOfDoc(doc) {
      return signedIn() && doc.studentId is string && doc.studentId == request.auth.uid;
    }

    /**
     * @description Rules for student profiles.
     * @path /students/{studentId}
     * @allow (read) Authenticated user can read own profile or an owner/admin.
     * @allow (create) Authenticated user can create a profile for themselves.
     * @allow (update) Authenticated user can update own profile or an owner can update.
     * @allow (delete) Authenticated user can delete own profile or an owner can delete.
     * @deny (read) Unauthorized user attempts to read another user's profile.
     * @deny (write) Unauthorized user attempts to modify another user's profile.
     * @principle Enforces user-ownership for profile data, with owner/admin override.
     */
    match /students/{studentId} {
      allow get:    if isOwner() || isAdmin() || (signedIn() && request.auth.uid == studentId);
      allow list:   if isOwner();
      allow create: if signedIn() && request.auth.uid == studentId;
      allow update: if isOwner() || (signedIn() && request.auth.uid == studentId);
      allow delete: if isOwner() || (signedIn() && request.auth.uid == studentId);
    }

    /**
     * @description Rules for song requests.
     * @path /song_requests/{songRequestId}
     * @allow (read) Owner, Admin, or Student who owns the song request can read.
     * @allow (create) Authenticated user can create a song request.
     * @allow (update) Owner or Student who owns the song request can update.
     * @allow (delete) Owner or Student who owns the song request can delete.
     * @deny (read) Unauthorized user attempts to read a song request they don't own.
     * @deny (write) Unauthorized user attempts to modify a song request they don't own.
     * @principle Enforces ownership for song requests, allowing students to manage their requests.
     */
    match /song_requests/{id} {
      allow get:    if isOwner() || isAdmin() || (signedIn() && getAfter().data.studentId == request.auth.uid);
      allow list:   if isOwner() || isAdmin();
      allow create: if signedIn() && request.resource.data.studentId is string && request.resource.data.studentId == request.auth.uid;
      allow update: if isOwner() || (signedIn() && getAfter().data.studentId == request.auth.uid);
      allow delete: if isOwner() || (signedIn() && getAfter().data.studentId == request.auth.uid);
    }

    /**
     * @description Rules for audit logs.
     * @path /audit_logs/{logId}
     * @allow (read) Only owners can read audit logs.
     * @allow (create) Authenticated user can create an audit log.
     * @deny (update, delete) No one can update or delete audit logs.
     * @principle Restricts access to sensitive audit logs to owners only.
     */
    match /audit_logs/{id} {
      allow get:    if isOwner();
      allow list:   if isOwner();
      allow create: if signedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Fallback rule to deny all other requests.
     * @path /{document=**}
     * @deny (read, write) All read and write requests to unmatched paths.
     * @principle Default-deny security posture.
     */
    match /{document=**} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}